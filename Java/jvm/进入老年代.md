## jvm中对象分配进入老年代的几种情况

### 大对象直接进入

大对象在minorGc中，造成没有足够的空间进入Survivor，导致频繁出发full gc，
大于配置参数的对像直接进入老年代。
> `-XX:PretenureSizeThreshold` 设置大对象阈值。

PS：在代码编写中避免出现短命的大对象。

### 长期存活对象进入

默认minor gc超过15次，对象将进入老年代。
> `-XX:MaxTenuringThreshold` 设置最大最大年龄

### 动态对象年龄判定

在surivor空间中的对象，相同年龄的对象的总大小超过survivor空间的一般，大于等于该年龄大小的对象进入老年代。

### 空间分配担保

minor gc过程中新生代所有的对象空间在老年代中是否有足够的空间分配，如果没有就进行一次full gc。


下面4种情况，对象会进入到老年代中：

-   YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。
    
-   经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。
    
-   动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。
    
-   大对象：由-XX:PretenureSizeThreshold启动参数控制，若对象大小大于此值，就会绕过新生代, 直接在老年代中分配。
    

当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），FGC处理的区域同时包括新生代和老年代。除此之外，还有以下4种情况也会触发FGC：

-   老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC。
    
-   空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。
    
-   Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。
    
-   System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。